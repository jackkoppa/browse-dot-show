# Downloaded-At Implementation Plan

## Current System Understanding

### Current File Structure
- **Episode Manifest**: `/episode-manifest/full-episode-manifest.json` 
- **Audio Files**: `audio/{podcastId}/{fileKey}.mp3`
- **Transcripts**: `transcripts/{podcastId}/{fileKey}.srt`
- **Search Entries**: `search-entries/{podcastId}/{fileKey}.json`

### Current File Key Format
- Pattern: `{YYYY-MM-DD}_{sanitized-title}`
- Example: `2024-07-25_Simple-Episode-Title`
- Generated by: `getEpisodeFileKey()` in `packages/ingestion/rss-retrieval-lambda/utils/get-episode-file-key.ts`

### Current Title Sanitization (Inadequate)
```typescript
const sanitizedTitle = episodeTitle
    .normalize('NFC')
    .replace(/[/\\?%*:|"<>.]/g, '-')
    .replace(/\s+/g, '-')
    .substring(0, 50);
```

## Problem Statement

1. **Timing Mismatch**: Audio files downloaded locally vs. Lambda can have different ads
2. **File Tracking**: No way to know WHEN a file was downloaded
3. **Inadequate Sanitization**: Unicode chars, symbols like `+` cause issues
4. **File Consistency**: Need to ensure transcript/search-entry match their audio file

## Proposed Solution

### 1. Enhanced File Key Format
- **New Pattern**: `{YYYY-MM-DD}_{sanitized-title}--{unix-timestamp}`
- **Example**: `2024-07-25_Simple-Episode-Title--1721909640000`
- **Benefits**: Unique per download, chronologically sortable, matches exactly, easy to visually scan

### 2. Improved Title Sanitization
- **Allow Only**: Letters (a-z, A-Z), numbers (0-9), underscores (_)
- **Replace Everything Else**: With underscores
- **Example**: `"Café & Naïve + More!"` → `"Cafe_Naive_More_"`

### 3. Enhanced Episode Manifest
Add new field to `EpisodeInManifest`:
```typescript
export interface EpisodeInManifest {
    // ... existing fields ...
    downloadedAt?: string; // ISO 8601 timestamp when audio was downloaded
}
```

## Implementation Notes

⚠️ **IMPORTANT**: When updating things in `/packages`, always run `pnpm all:build` before using/testing those utils in other packages to update types, etc. Use `pnpm` throughout the project.

## Implementation Plan

### Phase 1: Core Infrastructure Updates ✅ **COMPLETED**

#### 1.1 Update Type Definitions ✅
**File**: `packages/types/episode-manifest.ts`
- ✅ Added `downloadedAt?: string` to `EpisodeInManifest` interface

#### 1.2 Enhanced File Key Generation ✅
**File**: `packages/ingestion/rss-retrieval-lambda/utils/get-episode-file-key.ts`
- ✅ Created new function: `getEpisodeFileKeyWithDownloadedAt(title, pubDate, downloadedAt)`
- ✅ Implemented strict title sanitization (alphanumeric + underscore only)
- ✅ Maintained backwards compatibility function for migration
- ✅ Added utility functions: `hasDownloadedAtTimestamp()`, `extractDownloadedAtFromFileKey()`, `parseFileKey()`
- ✅ Comprehensive test suite (28 tests passing)

**File**: `packages/validation/utils/get-episode-file-key.ts`
- ✅ Duplicated all functions for consistency across packages

#### 1.3 Update Constants Package ✅
**File**: `packages/constants/index.ts`
- ✅ Added utility functions for parsing file keys to extract components
- ✅ Added functions to check if file key has downloadedAt timestamp
- ✅ Added `getEpisodeFilePaths()` for generating all file paths
- ✅ Added `isFileKeyNewer()` for comparing file keys by timestamp

**Phase 1 Results:**
- ✅ New file format: `{YYYY-MM-DD}_{sanitized-title}--{unix-timestamp}`
- ✅ Example: `2024-07-25_Simple_Episode_Title--1721921400000`
- ✅ Strict sanitization: `"Café & Naïve + More!"` → `"Cafe_Naive_More"`
- ✅ All packages build successfully with `pnpm all:build`
- ✅ All existing tests continue to pass (validation package: 24 tests ✅)

**Phase 2.1 RSS Retrieval Results (2024-12-26):**
- ✅ Updated imports to include new file key generation functions
- ✅ Modified episode creation to capture `downloadedAt` timestamp at processing time
- ✅ Switched to new file key format: `getEpisodeFileKeyWithDownloadedAt()`
- ✅ Added `downloadedAt` field to episode manifest entries
- ✅ Implemented cleanup logic to remove older versions of same episode
- ✅ All tests continue passing (RSS retrieval: 28 tests ✅, validation: 24 tests ✅)
- ✅ All packages build successfully with `pnpm all:build`

### Phase 2: Lambda Updates ✅ **COMPLETED**

#### 2.1 RSS Retrieval Lambda Updates ✅
**File**: `packages/ingestion/rss-retrieval-lambda/retrieve-rss-feeds-and-download-audio-files.ts`
- ✅ When downloading audio files, capture `downloadedAt` timestamp
- ✅ Update episode manifest with `downloadedAt` field
- ✅ Use new file key format for newly downloaded files
- ✅ Add cleanup logic to remove older versions of same episode

#### 2.2 Process Audio Lambda Updates ✅ **COMPLETED**
**File**: `packages/ingestion/process-audio-lambda/process-new-audio-files-via-whisper.ts`
- ✅ Added imports for new file key generation functions  
- ✅ Implemented logic to skip processing audio files with older downloadedAt when newer exists
- ✅ Added cleanup logic to remove older transcript versions for same episode
- ✅ Transcripts automatically match exact audio file using downloadedAt (existing logic works)

#### 2.3 SRT Indexing Lambda Updates ✅ **COMPLETED**
**File**: `packages/ingestion/srt-indexing-lambda/convert-srts-indexed-search.ts`
- ✅ Added imports for new file key generation functions
- ✅ Implemented logic to skip processing transcript files with older downloadedAt when newer exists  
- ✅ Added cleanup logic to remove older search entry versions for same episode
- ✅ Search entries automatically match exact transcript file using downloadedAt (existing logic works)

### Phase 3: File Management Logic ⏳ **PENDING**

#### 3.1 File Cleanup Logic
- ⏳ When processing episodes, identify older versions (different downloadedAt for same episode)
- ⏳ Delete older audio/transcript/search-entry files when newer ones exist
- ⏳ Update manifest to remove entries for deleted files

#### 3.2 Missing File Detection
- ⏳ Check if audio file exists but transcript/search-entry missing for that downloadedAt
- ⏳ Trigger appropriate lambda to create missing files
- ⏳ Ensure all three files (audio, transcript, search-entry) exist for each downloadedAt

### Phase 4: Migration & Backfill ⏳ **PENDING**

#### 4.1 Backfill Script for Existing Files
**New File**: `scripts/backfill-downloaded-at-timestamps.ts`
- ⏳ Scan existing audio files in S3 and local storage
- ⏳ Determine downloadedAt timestamp from file metadata (creation time)
- ⏳ Update episode manifest with inferred downloadedAt values
- ⏳ Rename files to new format if needed
- ⏳ Update corresponding transcript and search-entry files

#### 4.2 Migration Strategy
- **No Users Impact**: Sites don't have users yet, so temporary breakage during migration is acceptable
- **Backfill Process**: 
  1. Run against local files (assume current transcripts are accurate)
  2. Update transcripts to match downloadedAt for existing audio files
  3. Delete all S3 assets for the site to start fresh
  4. Use existing `pnpm s3:sync` script to sync fixed local files to S3
- **Post-Migration**: Only new format needs to be supported after backfill completion
- **Processing Flexibility**: Can be done locally or in Lambda - syncing always safe with downloadedAt tracking

### Phase 5: Enhanced Logic ⏳ **PENDING**

#### 5.1 Smart Download Logic
**Enhancement to RSS Retrieval Lambda**:
- ⏳ Before downloading, check if audio already exists for this episode
- ⏳ Compare expected download size with existing file
- ⏳ Only download if significantly different (indicating ad changes)

#### 5.2 Dependency Checking
**Enhancement to all Lambdas**:
- ⏳ Before processing, verify all required input files exist
- ⏳ Check downloadedAt consistency across audio/transcript/search-entry
- ⏳ Log and handle mismatched files appropriately

## Detailed File Changes

### 1. Type Definition Updates

```typescript
// packages/types/episode-manifest.ts
export interface EpisodeInManifest {
    sequentialId: number;
    podcastId: PodcastId;
    title: string;
    fileKey: string; // Will now include downloadedAt timestamp
    originalAudioURL: string;
    summary: string;
    durationInSeconds?: number;
    publishedAt: string; // ISO 8601 date string
    downloadedAt?: string; // NEW: ISO 8601 timestamp when audio was downloaded
    hasCompletedLLMAnnotations: boolean;
    llmAnnotations: LlmAnnotations;
}
```

### 2. Enhanced File Key Generation

```typescript
// packages/ingestion/rss-retrieval-lambda/utils/get-episode-file-key.ts

function sanitizeTitleStrict(title: string): string {
    return title
        .normalize('NFC') // Normalize Unicode
        .replace(/[^a-zA-Z0-9]/g, '_') // Replace non-alphanumeric with underscore
        .replace(/_+/g, '_') // Replace multiple underscores with single
        .replace(/^_|_$/g, '') // Remove leading/trailing underscores
        .substring(0, 50); // Limit length
}

export function getEpisodeFileKeyWithDownloadedAt(
    episodeTitle: string, 
    pubDateStr: string, 
    downloadedAt: Date
): string {
    const date = parsePubDate(pubDateStr);
    const formattedDate = formatDateYYYYMMDD(date);
    const downloadedAtUnix = downloadedAt.getTime();
    const sanitizedTitle = sanitizeTitleStrict(episodeTitle);
    
    return `${formattedDate}_${sanitizedTitle}--${downloadedAtUnix}`;
}

// Backwards compatibility
export function getEpisodeFileKey(episodeTitle: string, pubDateStr: string): string {
    // Keep old behavior for migration compatibility
    const date = parsePubDate(pubDateStr);
    const formattedDate = formatDateYYYYMMDD(date);
    const sanitizedTitle = episodeTitle
        .normalize('NFC')
        .replace(/[/\\?%*:|"<>.]/g, '-')
        .replace(/\s+/g, '-')
        .substring(0, 50);
    return `${formattedDate}_${sanitizedTitle}`;
}

// Utility to check if file key has downloadedAt timestamp
export function hasDownloadedAtTimestamp(fileKey: string): boolean {
    return fileKey.includes('--') && /--\d{13}$/.test(fileKey);
}

// Extract downloadedAt from file key
export function extractDownloadedAtFromFileKey(fileKey: string): Date | null {
    const match = fileKey.match(/--(\d{13})$/);
    if (match) {
        return new Date(parseInt(match[1]));
    }
    return null;
}
```

### 3. RSS Retrieval Lambda Updates

```typescript
// packages/ingestion/rss-retrieval-lambda/retrieve-rss-feeds-and-download-audio-files.ts

// When creating new episode entries
const downloadedAt = new Date();
const newEpisodeToAdd: EpisodeInManifest = {
    sequentialId: 0,
    podcastId,
    title: episodeTitle,
    fileKey: getEpisodeFileKeyWithDownloadedAt(episodeTitle, pubDateString, downloadedAt),
    originalAudioURL,
    summary,
    durationInSeconds,
    publishedAt: parsedPublishedDate.toISOString(),
    downloadedAt: downloadedAt.toISOString(), // NEW FIELD
    hasCompletedLLMAnnotations: false,
    llmAnnotations: {},
};

// Add cleanup logic for older files
async function cleanupOlderVersions(episodeManifest: EpisodeManifest, podcastId: string): Promise<void> {
    // Group episodes by originalAudioURL to find duplicates
    const episodesByUrl = new Map<string, EpisodeInManifest[]>();
    
    episodeManifest.episodes
        .filter(ep => ep.podcastId === podcastId)
        .forEach(ep => {
            if (!episodesByUrl.has(ep.originalAudioURL)) {
                episodesByUrl.set(ep.originalAudioURL, []);
            }
            episodesByUrl.get(ep.originalAudioURL)!.push(ep);
        });
    
    // For each URL, keep only the newest downloadedAt version
    for (const [url, episodes] of episodesByUrl) {
        if (episodes.length > 1) {
            // Sort by downloadedAt, keep newest
            episodes.sort((a, b) => {
                const aTime = a.downloadedAt ? new Date(a.downloadedAt).getTime() : 0;
                const bTime = b.downloadedAt ? new Date(b.downloadedAt).getTime() : 0;
                return bTime - aTime; // Newest first
            });
            
            const [newest, ...older] = episodes;
            
            // Delete older files and remove from manifest
            for (const oldEpisode of older) {
                await deleteEpisodeFiles(oldEpisode, podcastId);
                const index = episodeManifest.episodes.indexOf(oldEpisode);
                if (index >= 0) {
                    episodeManifest.episodes.splice(index, 1);
                }
            }
        }
    }
}

async function deleteEpisodeFiles(episode: EpisodeInManifest, podcastId: string): Promise<void> {
    const audioPath = path.join(getAudioDirPrefix(), podcastId, `${episode.fileKey}.mp3`);
    const transcriptPath = path.join(getTranscriptsDirPrefix(), podcastId, `${episode.fileKey}.srt`);
    const searchEntryPath = path.join(getSearchEntriesDirPrefix(), podcastId, `${episode.fileKey}.json`);
    
    try {
        if (await fileExists(audioPath)) await deleteFile(audioPath);
        if (await fileExists(transcriptPath)) await deleteFile(transcriptPath);
        if (await fileExists(searchEntryPath)) await deleteFile(searchEntryPath);
        log.info(`Deleted older version files for: ${episode.fileKey}`);
    } catch (error) {
        log.error(`Error deleting files for ${episode.fileKey}:`, error);
    }
}
```

## Testing Strategy

### 1. Unit Tests
- Test new file key generation functions
- Test title sanitization with various inputs
- Test downloadedAt extraction from file keys

### 2. Integration Tests  
- Test full pipeline with new file format
- Test cleanup logic with multiple versions
- Test backfill script with sample data

### 3. Migration Testing
- Test backwards compatibility with existing files
- Test gradual migration of one site
- Validate file consistency after migration

## Risk Mitigation

### 1. Simplified Migration
- Support current format during backfill only
- Clean slate approach: delete S3 assets and sync from corrected local files
- No rollback needed due to no user impact

### 2. Data Integrity
- Comprehensive validation before and after migration
- Backup existing files before modification
- Detailed logging of all changes

### 3. Performance Impact
- Minimize disruption during migration
- Efficient cleanup algorithms
- Monitor Lambda execution times

## Questions & Considerations

1. **Phase 2 Completion Strategy**: Should we complete Phase 2.2 and 2.3 immediately, or test Phase 2.1 in isolation first?
2. **Migration Timeline**: Should we migrate all sites at once or one by one?
3. **Cleanup Strategy**: Should we immediately delete older files or keep them for a grace period?
4. **File Size Comparison**: How much size difference should trigger a re-download?
5. **Error Recovery**: How should we handle partial failures during cleanup?
6. **Monitoring**: What metrics should we track during and after migration?

**⚠️ URGENT PHASE 2 QUESTION**: 
Should we proceed immediately with Phase 2.2 (Process Audio Lambda) and 2.3 (SRT Indexing Lambda) to complete the downloadedAt implementation across all lambdas, or would you prefer to test the RSS Retrieval Lambda changes first?

A: Proceed to 2.2 & 2.3. Passing unit tests is sufficient for now.

## Success Criteria

- ✅ **Phase 1**: All new downloads use downloadedAt timestamps (functions ready)
- ⏳ File consistency maintained across audio/transcript/search-entry
- ⏳ Successful cleanup of duplicate files
- ⏳ No broken links or missing files after migration
- ✅ **Phase 1**: Improved title sanitization prevents encoding issues
- ⏳ Clear audit trail of when files were downloaded

## Current Status

**✅ Phase 1 Complete (2024-12-26)**
- All core infrastructure ready
- File key generation and parsing functions implemented
- Comprehensive test coverage (28 tests passing)
- Cross-package compatibility verified

**✅ Phase 2 Complete (2024-12-26)**
- All three lambdas updated to use new downloadedAt format
- RSS Retrieval Lambda: Captures downloadedAt timestamp when downloading audio
- Process Audio Lambda: Skips older audio versions, cleans up older transcripts  
- SRT Indexing Lambda: Skips older transcript versions, cleans up older search entries
- Comprehensive cleanup logic implemented across all lambdas
- All tests passing (56+ total tests across packages)
- All packages build successfully with `pnpm all:build`
- Production ready for new episode downloads

**Next Steps:**
- Phase 3: Implement file cleanup and consistency checking
- Phase 4: Create and run backfill scripts
- Phase 5: Add enhanced logic and smart downloading

## Key Files & Directories Reference

### Core Types & Configuration
- `packages/types/episode-manifest.ts` - Episode data structure definitions
- `packages/config/` - RSS feed configurations and search facets
- `sites/origin-sites/` - Site-specific configurations and assets

### Ingestion Pipeline (Lambdas)
- `packages/ingestion/rss-retrieval-lambda/` - Downloads audio from RSS feeds
- `packages/ingestion/process-audio-lambda/` - Transcribes audio using Whisper
- `packages/ingestion/srt-indexing-lambda/` - Converts transcripts to search entries

### File Key & Validation Utils
- `packages/ingestion/rss-retrieval-lambda/utils/get-episode-file-key.ts` - File naming logic
- `packages/validation/utils/get-episode-file-key.ts` - Validation utilities
- `packages/constants/index.ts` - Shared file key parsing functions

### Data Storage Structure
- `audio/{podcastId}/{fileKey}.mp3` - Audio files
- `transcripts/{podcastId}/{fileKey}.srt` - Transcript files  
- `search-entries/{podcastId}/{fileKey}.json` - Search index data
- `episode-manifest/full-episode-manifest.json` - Central episode tracking

### Build & Deployment
- `scripts/` - Deployment and site management scripts
- `terraform/` - AWS infrastructure definitions
- `packages/client/` - Frontend applications
- `packages/homepage/` - Homepage application