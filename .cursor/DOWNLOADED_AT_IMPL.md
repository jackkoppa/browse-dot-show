# Downloaded-At Implementation Plan

## Current System Understanding

### Current File Structure
- **Episode Manifest**: `/episode-manifest/full-episode-manifest.json` 
- **Audio Files**: `audio/{podcastId}/{fileKey}.mp3`
- **Transcripts**: `transcripts/{podcastId}/{fileKey}.srt`
- **Search Entries**: `search-entries/{podcastId}/{fileKey}.json`

### Current File Key Format
- Pattern: `{YYYY-MM-DD}_{sanitized-title}`
- Example: `2024-07-25_Simple-Episode-Title`
- Generated by: `getEpisodeFileKey()` in `packages/ingestion/rss-retrieval-lambda/utils/get-episode-file-key.ts`

### Current Title Sanitization (Inadequate)
```typescript
const sanitizedTitle = episodeTitle
    .normalize('NFC')
    .replace(/[/\\?%*:|"<>.]/g, '-')
    .replace(/\s+/g, '-')
    .substring(0, 50);
```

## Problem Statement

1. **Timing Mismatch**: Audio files downloaded locally vs. Lambda can have different ads
2. **File Tracking**: No way to know WHEN a file was downloaded
3. **Inadequate Sanitization**: Unicode chars, symbols like `+` cause issues
4. **File Consistency**: Need to ensure transcript/search-entry match their audio file

## Proposed Solution

### 1. Enhanced File Key Format
- **New Pattern**: `{YYYY-MM-DD}_{sanitized-title}--{unix-timestamp}`
- **Example**: `2024-07-25_Simple-Episode-Title--1721909640000`
- **Benefits**: Unique per download, chronologically sortable, matches exactly, easy to visually scan

### 2. Improved Title Sanitization
- **Allow Only**: Letters (a-z, A-Z), numbers (0-9), underscores (_)
- **Replace Everything Else**: With underscores
- **Example**: `"Café & Naïve + More!"` → `"Cafe_Naive_More_"`

### 3. Enhanced Episode Manifest
Add new field to `EpisodeInManifest`:
```typescript
export interface EpisodeInManifest {
    // ... existing fields ...
    downloadedAt?: string; // ISO 8601 timestamp when audio was downloaded
}
```

## Implementation Notes

⚠️ **IMPORTANT**: When updating things in `/packages`, always run `pnpm all:build` before using/testing those utils in other packages to update types, etc. Use `pnpm` throughout the project.

## Implementation Plan

### Phase 1: Core Infrastructure Updates

#### 1.1 Update Type Definitions
**File**: `packages/types/episode-manifest.ts`
- Add `downloadedAt?: string` to `EpisodeInManifest` interface

#### 1.2 Enhanced File Key Generation
**File**: `packages/ingestion/rss-retrieval-lambda/utils/get-episode-file-key.ts`
- Create new function: `getEpisodeFileKeyWithDownloadedAt(title, pubDate, downloadedAt)`
- Improve title sanitization to alphanumeric + underscore only
- Add backwards compatibility function for migration

#### 1.3 Update Constants Package
**File**: `packages/constants/index.ts`
- Add utility functions for parsing file keys to extract components
- Add functions to check if file key has downloadedAt timestamp

### Phase 2: Lambda Updates

#### 2.1 RSS Retrieval Lambda Updates
**File**: `packages/ingestion/rss-retrieval-lambda/retrieve-rss-feeds-and-download-audio-files.ts`
- When downloading audio files, capture `downloadedAt` timestamp
- Update episode manifest with `downloadedAt` field
- Use new file key format for newly downloaded files
- Add cleanup logic to remove older versions of same episode

#### 2.2 Process Audio Lambda Updates  
**File**: `packages/ingestion/process-audio-lambda/process-new-audio-files-via-whisper.ts`
- Ensure transcripts match the exact audio file (using downloadedAt)
- Check if transcript already exists for the specific downloadedAt
- Generate transcripts with matching file key format

#### 2.3 SRT Indexing Lambda Updates
**File**: `packages/ingestion/srt-indexing-lambda/convert-srts-indexed-search.ts`
- Ensure search entries match exact transcript file (using downloadedAt)
- Check if search entry already exists for specific downloadedAt
- Generate search entries with matching file key format

### Phase 3: File Management Logic

#### 3.1 File Cleanup Logic
- When processing episodes, identify older versions (different downloadedAt for same episode)
- Delete older audio/transcript/search-entry files when newer ones exist
- Update manifest to remove entries for deleted files

#### 3.2 Missing File Detection
- Check if audio file exists but transcript/search-entry missing for that downloadedAt
- Trigger appropriate lambda to create missing files
- Ensure all three files (audio, transcript, search-entry) exist for each downloadedAt

### Phase 4: Migration & Backfill

#### 4.1 Backfill Script for Existing Files
**New File**: `scripts/backfill-downloaded-at-timestamps.ts`
- Scan existing audio files in S3 and local storage
- Determine downloadedAt timestamp from file metadata (creation time)
- Update episode manifest with inferred downloadedAt values
- Rename files to new format if needed
- Update corresponding transcript and search-entry files

#### 4.2 Migration Strategy
- **No Users Impact**: Sites don't have users yet, so temporary breakage during migration is acceptable
- **Backfill Process**: 
  1. Run against local files (assume current transcripts are accurate)
  2. Update transcripts to match downloadedAt for existing audio files
  3. Delete all S3 assets for the site to start fresh
  4. Use existing `pnpm s3:sync` script to sync fixed local files to S3
- **Post-Migration**: Only new format needs to be supported after backfill completion
- **Processing Flexibility**: Can be done locally or in Lambda - syncing always safe with downloadedAt tracking

### Phase 5: Enhanced Logic

#### 5.1 Smart Download Logic
**Enhancement to RSS Retrieval Lambda**:
- Before downloading, check if audio already exists for this episode
- Compare expected download size with existing file
- Only download if significantly different (indicating ad changes)

#### 5.2 Dependency Checking
**Enhancement to all Lambdas**:
- Before processing, verify all required input files exist
- Check downloadedAt consistency across audio/transcript/search-entry
- Log and handle mismatched files appropriately

## Detailed File Changes

### 1. Type Definition Updates

```typescript
// packages/types/episode-manifest.ts
export interface EpisodeInManifest {
    sequentialId: number;
    podcastId: PodcastId;
    title: string;
    fileKey: string; // Will now include downloadedAt timestamp
    originalAudioURL: string;
    summary: string;
    durationInSeconds?: number;
    publishedAt: string; // ISO 8601 date string
    downloadedAt?: string; // NEW: ISO 8601 timestamp when audio was downloaded
    hasCompletedLLMAnnotations: boolean;
    llmAnnotations: LlmAnnotations;
}
```

### 2. Enhanced File Key Generation

```typescript
// packages/ingestion/rss-retrieval-lambda/utils/get-episode-file-key.ts

function sanitizeTitleStrict(title: string): string {
    return title
        .normalize('NFC') // Normalize Unicode
        .replace(/[^a-zA-Z0-9]/g, '_') // Replace non-alphanumeric with underscore
        .replace(/_+/g, '_') // Replace multiple underscores with single
        .replace(/^_|_$/g, '') // Remove leading/trailing underscores
        .substring(0, 50); // Limit length
}

export function getEpisodeFileKeyWithDownloadedAt(
    episodeTitle: string, 
    pubDateStr: string, 
    downloadedAt: Date
): string {
    const date = parsePubDate(pubDateStr);
    const formattedDate = formatDateYYYYMMDD(date);
    const downloadedAtUnix = downloadedAt.getTime();
    const sanitizedTitle = sanitizeTitleStrict(episodeTitle);
    
    return `${formattedDate}_${sanitizedTitle}--${downloadedAtUnix}`;
}

// Backwards compatibility
export function getEpisodeFileKey(episodeTitle: string, pubDateStr: string): string {
    // Keep old behavior for migration compatibility
    const date = parsePubDate(pubDateStr);
    const formattedDate = formatDateYYYYMMDD(date);
    const sanitizedTitle = episodeTitle
        .normalize('NFC')
        .replace(/[/\\?%*:|"<>.]/g, '-')
        .replace(/\s+/g, '-')
        .substring(0, 50);
    return `${formattedDate}_${sanitizedTitle}`;
}

// Utility to check if file key has downloadedAt timestamp
export function hasDownloadedAtTimestamp(fileKey: string): boolean {
    return fileKey.includes('--') && /--\d{13}$/.test(fileKey);
}

// Extract downloadedAt from file key
export function extractDownloadedAtFromFileKey(fileKey: string): Date | null {
    const match = fileKey.match(/--(\d{13})$/);
    if (match) {
        return new Date(parseInt(match[1]));
    }
    return null;
}
```

### 3. RSS Retrieval Lambda Updates

```typescript
// packages/ingestion/rss-retrieval-lambda/retrieve-rss-feeds-and-download-audio-files.ts

// When creating new episode entries
const downloadedAt = new Date();
const newEpisodeToAdd: EpisodeInManifest = {
    sequentialId: 0,
    podcastId,
    title: episodeTitle,
    fileKey: getEpisodeFileKeyWithDownloadedAt(episodeTitle, pubDateString, downloadedAt),
    originalAudioURL,
    summary,
    durationInSeconds,
    publishedAt: parsedPublishedDate.toISOString(),
    downloadedAt: downloadedAt.toISOString(), // NEW FIELD
    hasCompletedLLMAnnotations: false,
    llmAnnotations: {},
};

// Add cleanup logic for older files
async function cleanupOlderVersions(episodeManifest: EpisodeManifest, podcastId: string): Promise<void> {
    // Group episodes by originalAudioURL to find duplicates
    const episodesByUrl = new Map<string, EpisodeInManifest[]>();
    
    episodeManifest.episodes
        .filter(ep => ep.podcastId === podcastId)
        .forEach(ep => {
            if (!episodesByUrl.has(ep.originalAudioURL)) {
                episodesByUrl.set(ep.originalAudioURL, []);
            }
            episodesByUrl.get(ep.originalAudioURL)!.push(ep);
        });
    
    // For each URL, keep only the newest downloadedAt version
    for (const [url, episodes] of episodesByUrl) {
        if (episodes.length > 1) {
            // Sort by downloadedAt, keep newest
            episodes.sort((a, b) => {
                const aTime = a.downloadedAt ? new Date(a.downloadedAt).getTime() : 0;
                const bTime = b.downloadedAt ? new Date(b.downloadedAt).getTime() : 0;
                return bTime - aTime; // Newest first
            });
            
            const [newest, ...older] = episodes;
            
            // Delete older files and remove from manifest
            for (const oldEpisode of older) {
                await deleteEpisodeFiles(oldEpisode, podcastId);
                const index = episodeManifest.episodes.indexOf(oldEpisode);
                if (index >= 0) {
                    episodeManifest.episodes.splice(index, 1);
                }
            }
        }
    }
}

async function deleteEpisodeFiles(episode: EpisodeInManifest, podcastId: string): Promise<void> {
    const audioPath = path.join(getAudioDirPrefix(), podcastId, `${episode.fileKey}.mp3`);
    const transcriptPath = path.join(getTranscriptsDirPrefix(), podcastId, `${episode.fileKey}.srt`);
    const searchEntryPath = path.join(getSearchEntriesDirPrefix(), podcastId, `${episode.fileKey}.json`);
    
    try {
        if (await fileExists(audioPath)) await deleteFile(audioPath);
        if (await fileExists(transcriptPath)) await deleteFile(transcriptPath);
        if (await fileExists(searchEntryPath)) await deleteFile(searchEntryPath);
        log.info(`Deleted older version files for: ${episode.fileKey}`);
    } catch (error) {
        log.error(`Error deleting files for ${episode.fileKey}:`, error);
    }
}
```

## Testing Strategy

### 1. Unit Tests
- Test new file key generation functions
- Test title sanitization with various inputs
- Test downloadedAt extraction from file keys

### 2. Integration Tests  
- Test full pipeline with new file format
- Test cleanup logic with multiple versions
- Test backfill script with sample data

### 3. Migration Testing
- Test backwards compatibility with existing files
- Test gradual migration of one site
- Validate file consistency after migration

## Risk Mitigation

### 1. Simplified Migration
- Support current format during backfill only
- Clean slate approach: delete S3 assets and sync from corrected local files
- No rollback needed due to no user impact

### 2. Data Integrity
- Comprehensive validation before and after migration
- Backup existing files before modification
- Detailed logging of all changes

### 3. Performance Impact
- Minimize disruption during migration
- Efficient cleanup algorithms
- Monitor Lambda execution times

## Questions & Considerations

1. **Migration Timeline**: Should we migrate all sites at once or one by one?
2. **Cleanup Strategy**: Should we immediately delete older files or keep them for a grace period?
3. **File Size Comparison**: How much size difference should trigger a re-download?
4. **Error Recovery**: How should we handle partial failures during cleanup?
5. **Monitoring**: What metrics should we track during and after migration?

## Success Criteria

- All new downloads use downloadedAt timestamps
- File consistency maintained across audio/transcript/search-entry
- Successful cleanup of duplicate files
- No broken links or missing files after migration
- Improved title sanitization prevents encoding issues
- Clear audit trail of when files were downloaded